# This file was automatically generated by alf
# https://github.com/dannyben/alf

unalias all-groups 1>/dev/null 2>&1
all-groups() {
  cut -d: -f1 /etc/group | sort "$@"
}

unalias cats 1>/dev/null 2>&1
cats() {
  highlight --line-numbers --line-number-length=3 --line-length=75 --wrap-simple --wrap-no-numbers --out-format=ansi --force "$@"
}

unalias cdc 1>/dev/null 2>&1
cdc() {
  cd ./$1
}

unalias cdp 1>/dev/null 2>&1
cdp() {
  cd ~/Projects; clear; pwd "$@"
}

unalias c 1>/dev/null 2>&1
c() {
  cd $1; clear; pwd
}

unalias compare-dir 1>/dev/null 2>&1
compare-dir() {
  diff --brief -Nr  "$@"
}

unalias count 1>/dev/null 2>&1
count() {
  ls -1 ${1:-.} | wc -l
}

unalias cm 1>/dev/null 2>&1
cm() {
  chmod $1 $2
}

unalias cmr 1>/dev/null 2>&1
cmr() {
  chmod $1 -R $2
}

unalias co 1>/dev/null 2>&1
co() {
  chown $1 $2
}

unalias cor 1>/dev/null 2>&1
cor() {
  chown $1 -R $2
}

unalias d 1>/dev/null 2>&1
d() {
  if [[ $1 = "psf" ]]; then
    shift
    docker ps --format "{{.ID}} {{.Names}}\t{{.Status}}  {{.Ports}}" "$@"
  elif [[ $1 = "paf" ]]; then
    shift
    docker ps -a --format="table {{.Names}}\t{{.Status}}\t{{.ID}}" "$@"
  elif [[ $1 = "p" ]]; then
    shift
    docker ps -a "$@"
  elif [[ $1 = "clean" ]]; then
    shift
    docker system prune -f "$@"
  elif [[ $1 = "deploy" ]]; then
    shift
    docker stack deploy -c $1.yml $1
  elif [[ $1 = "i" ]]; then
    shift
    docker images --format "table {{.Repository}}\t{{.Tag}}\t{{.Size}}" "$@"
  elif [[ $1 = "images" ]]; then
    shift
    docker images --format "table {{.Repository}}\t{{.Tag}}\t{{.Size}}" "$@"
  elif [[ $1 = "n" ]]; then
    shift
    docker network "$@"
  elif [[ $1 = "rmi" ]]; then
    shift
    docker images --format "{{.Repository}}:{{.Tag}}" |grep $1 | xargs docker rmi -f
  elif [[ $1 = "rmv" ]]; then
    shift
    docker volume ls --format "{{.Name}}" |grep $1 |xargs docker volume rm -f
  elif [[ $1 = "v" ]]; then
    shift
    docker volume "$@"
  elif [[ $1 = "r" ]]; then
    shift
    docker run -it --rm  "$@"
  elif [[ $1 = "replicas" ]]; then
    shift
    docker service ls --format='table {{.Name}}\t{{.Mode}}\t{{.Replicas}}' "$@"
  elif [[ $1 = "s" ]]; then
    shift
    docker service "$@"
  elif [[ $1 = "st" ]]; then
    shift
    docker stack "$@"
  elif [[ $1 = "size" ]]; then
    shift
    docker images --format '{{.Size}}\t{{.Repository}}:{{.Tag}}' | sort -h | column -t "$@"
  elif [[ $1 = "stats" ]]; then
    shift
    docker stats --format "{{.Name}}\t{{.CPUPerc}}\t{{.MemUsage}}" "$@"
  else
    docker "$@"
  fi
}

unalias dc 1>/dev/null 2>&1
dc() {
  if [[ $1 = "ud" ]]; then
    shift
    docker-compose up -d "$@"
  elif [[ $1 = "ub" ]]; then
    shift
    docker-compose up -d --build "$@"
  elif [[ $1 = "ur" ]]; then
    shift
    docker-compose up -d --force-recreate "$@"
  elif [[ $1 = "ubr" ]]; then
    shift
    docker-compose up -d --build --force-recreate "$@"
  elif [[ $1 = "u" ]]; then
    shift
    docker-compose up "$@"
  elif [[ $1 = "eb" ]]; then
    shift
    docker-compose exec $1 /bin/bash
  elif [[ $1 = "e" ]]; then
    shift
    docker-compose exec $1 ${@:2}
  elif [[ $1 = "rb" ]]; then
    shift
    docker-compose run --rm $1 /bin/bash
  elif [[ $1 = "r" ]]; then
    shift
    docker-compose run --rm $1 ${@:2}
  elif [[ $1 = "d" ]]; then
    shift
    docker-compose down "$@"
  elif [[ $1 = "sael" ]]; then
    shift
    docker-compose exec $1 cat /var/log/apache2/error.log
  elif [[ $1 = "stael" ]]; then
    shift
    docker-compose exec $1 tail -f /var/log/apache2/error.log
  elif [[ $1 = "lf" ]]; then
    shift
    docker-compose logs -f "$@"
  else
    docker-compose "$@"
  fi
}

unalias odc 1>/dev/null 2>&1
odc() {
  if [[ $1 = "ud" ]]; then
    shift
    op dc up -d "$@"
  elif [[ $1 = "ub" ]]; then
    shift
    op dc up -d --build "$@"
  elif [[ $1 = "ur" ]]; then
    shift
    op dc up -d --force-recreate "$@"
  elif [[ $1 = "ubr" ]]; then
    shift
    op dc up -d --build --force-recreate "$@"
  elif [[ $1 = "u" ]]; then
    shift
    op dc up "$@"
  elif [[ $1 = "eb" ]]; then
    shift
    op dc exec $1 /bin/bash
  elif [[ $1 = "e" ]]; then
    shift
    op dc exec $1 ${@:2}
  elif [[ $1 = "rb" ]]; then
    shift
    op dc run $1 /bin/bash
  elif [[ $1 = "r" ]]; then
    shift
    op dc run $1 ${@:2}
  elif [[ $1 = "d" ]]; then
    shift
    op dc down "$@"
  elif [[ $1 = "sael" ]]; then
    shift
    op dc exec $1 cat /var/log/apache2/error.log
  elif [[ $1 = "lf" ]]; then
    shift
    op dc logs -f "$@"
  else
    op dc "$@"
  fi
}

unalias dclf 1>/dev/null 2>&1
dclf() {
  dc logs -f "$@"
}

unalias dfh 1>/dev/null 2>&1
dfh() {
  df -H "$@"
}

unalias dfhd 1>/dev/null 2>&1
dfhd() {
  df -H | grep -v -e "/dev/loop" -e "tmpfs" -e "udev" "$@"
}

unalias duh 1>/dev/null 2>&1
duh() {
  du -ach "$@"
}

unalias dps 1>/dev/null 2>&1
dps() {
  d ps "$@"
}

unalias dpsa 1>/dev/null 2>&1
dpsa() {
  d ps -a "$@"
}

unalias f 1>/dev/null 2>&1
f() {
  find |grep "$@"
}

unalias g 1>/dev/null 2>&1
g() {
  if [[ $1 = "s" ]]; then
    shift
    git status "$@"
  elif [[ $1 = "l" ]]; then
    shift
    git log --all --graph --date=relative --pretty=format:'%h %Cgreen%ad%Creset %Cblue%an%Creset%n        %s%n       %C(auto)%d%Creset' "$@"
  elif [[ $1 = "ll" ]]; then
    shift
    git log --graph --oneline --decorate --all "$@"
  elif [[ $1 = "tail" ]]; then
    shift
    git log -${1:-5} --all --date=relative --pretty=format:'%h %Cgreen%ad%Creset %x09%Cblue%s%Creset'
  elif [[ $1 = "c" ]]; then
    shift
    git add . --all && git commit -am "$@"
  elif [[ $1 = "p" ]]; then
    shift
    git push "$@"
  elif [[ $1 = "m" ]]; then
    shift
    git merge "$@"
  elif [[ $1 = "b" ]]; then
    shift
    git branch "$@"
  elif [[ $1 = "d" ]]; then
    shift
    git diff "$@"
  elif [[ $1 = "co" ]]; then
    shift
    git checkout "$@"
  elif [[ $1 = "cp" ]]; then
    shift
    git cherry-pick "$@"
  elif [[ $1 = "pl" ]]; then
    shift
    git pull "$@"
  elif [[ $1 = "ls" ]]; then
    shift
    git ls-tree --full-name --name-only -r HEAD "$@"
  elif [[ $1 = "chmod" ]]; then
    shift
    git update-index --chmod  "$@"
  elif [[ $1 = "compare" ]]; then
    shift
    git diff --stat --color $1..HEAD
  elif [[ $1 = "datelog" ]]; then
    shift
    git log --pretty=format:'%h %ad%x09%an%x09%s' --date=short "$@"
  elif [[ $1 = "discard" ]]; then
    shift
    git checkout -- . ; git clean -fd "$@"
  elif [[ $1 = "history" ]]; then
    shift
    git log -p "$@"
  elif [[ $1 = "optimize" ]]; then
    shift
    git repack -ad && sleep 2 && git gc "$@"
  elif [[ $1 = "remote-delete" ]]; then
    shift
    git push origin --delete "$@"
  elif [[ $1 = "rebuild" ]]; then
    shift
    git commit --allow-empty -m "trigger rebuild" ; git push "$@"
  elif [[ $1 = "rename" ]]; then
    shift
    git branch -m "$@"
  elif [[ $1 = "resolve-ours" ]]; then
    shift
    git checkout --ours . ; git add -u ; git commit -m 'resolve conflicts with --ours' "$@"
  elif [[ $1 = "resolve-theirs" ]]; then
    shift
    git checkout --theirs . ; git add -u ; git commit -m 'resolve conflicts with --theirs' "$@"
  elif [[ $1 = "rollback" ]]; then
    shift
    git revert --no-commit $1..HEAD
  elif [[ $1 = "shallow-clone" ]]; then
    shift
    git clone --depth 1 "$@"
  elif [[ $1 = "upstream" ]]; then
    shift
    git checkout master && git fetch upstream && git merge upstream/master "$@"
  elif [[ $1 = "age" ]]; then
    shift
    for d in ./*/; do echo -e "\n\e[34m$d\e[0m" ; git -C $d log -1 --all --date=relative --pretty=format:'%Cgreen%ad%Creset %x09%s%n' ; done;
  else
    git "$@"
  fi
}

unalias gg 1>/dev/null 2>&1
gg() {
  g p "$@"
}

unalias ggt 1>/dev/null 2>&1
ggt() {
  gg && gg --tag "$@"
}

unalias gpl 1>/dev/null 2>&1
gpl() {
  g pl "$@"
}

unalias inst 1>/dev/null 2>&1
inst() {
  sudo apt install "$@"
}

unalias uninst 1>/dev/null 2>&1
uninst() {
  sudo apt remove "$@"
}

unalias killport 1>/dev/null 2>&1
killport() {
  [[ $(lsof -ti:$1) ]] && kill -9 $(lsof -ti:$1)
}

unalias l 1>/dev/null 2>&1
l() {
  ls -lah "$@"
}

unalias le 1>/dev/null 2>&1
le() {
  exa -lah "$@"
}

unalias less 1>/dev/null 2>&1
less() {
  command less -S "$@"
}

unalias myip 1>/dev/null 2>&1
myip() {
  ifconfig |head -n2 |sed -rn 's/.*addr:([^ ]+) .*/\1/p' "$@"
}

unalias nv 1>/dev/null 2>&1
nv() {
  env |grep -i "$@"
}

unalias nush 1>/dev/null 2>&1
nush() {
  nu -c "${@:1}"
}

unalias nsh 1>/dev/null 2>&1
nsh() {
  if [[ $1 = "host" ]]; then
    shift
    nu -c "sys | get host" "$@"
  else
    nu "$@"
  fi
}

unalias port 1>/dev/null 2>&1
port() {
  sudo lsof -i :$1
}

unalias ports 1>/dev/null 2>&1
ports() {
  sudo netstat -tulpn | grep LISTEN |grep -Po '(?<=:)(\d{2,5})' |sort -n  |uniq |tr '\n' '\t' "$@"
}

unalias psf 1>/dev/null 2>&1
psf() {
  ps -ef |grep  "$@"
}

unalias py 1>/dev/null 2>&1
py() {
  python3 "$@"
}

unalias repeat 1>/dev/null 2>&1
repeat() {
  for i in `seq $1`; do ${@:2} ; done
}

unalias runas 1>/dev/null 2>&1
runas() {
  sudo su -s /bin/sh $1 -c "$2"
}

unalias r 1>/dev/null 2>&1
r() {
  clear; ${@:1}
}

unalias syslog 1>/dev/null 2>&1
syslog() {
  sudo grc tail -f /var/log/syslog "$@"
}

unalias tracert 1>/dev/null 2>&1
tracert() {
  sudo traceroute -I  "$@"
}

unalias title 1>/dev/null 2>&1
title() {
  echo -ne "\033]0;${@:1}\007"
}

unalias update 1>/dev/null 2>&1
update() {
  sudo apt update; sudo apt upgrade -y; sudo apt autoremove; brew update; brew upgrade; sudo snap refresh "$@"
}

unalias superlinter 1>/dev/null 2>&1
superlinter() {
  sudo docker pull github/super-linter:latest; sudo docker run -e RUN_LOCAL=true -v $PWD:/tmp/lint github/super-linter
}

unalias ver 1>/dev/null 2>&1
ver() {
  lsb_release -drc "$@"
}

unalias what 1>/dev/null 2>&1
what() {
  alf which "$@"
}

unalias p 1>/dev/null 2>&1
p() {
  pwbs "$@"
}

unalias a 1>/dev/null 2>&1
a() {
  alf "$@"
}

unalias als 1>/dev/null 2>&1
als() {
  alf s; reload_bash "$@"
}

unalias y 1>/dev/null 2>&1
y() {
  yarn "$@"
}

unalias n 1>/dev/null 2>&1
n() {
  npm "$@"
}

unalias v 1>/dev/null 2>&1
v() {
  nvim "$@"
}

unalias w 1>/dev/null 2>&1
w() {
  if [[ $1 = "dfh" ]]; then
    shift
    echo "starting watcher"; for ((i=1; i>0; i+=1)); do r dfh; echo "Rendered $i time"; sleep 1; done
  elif [[ $1 = "odc-ps" ]]; then
    shift
    echo "starting watcher"; for ((i=1; i>0; i+=1)); do r odc ps; echo "Rendered $i time"; sleep 1;done
  elif [[ $1 = "dc-ps" ]]; then
    shift
    echo "starting watcher"; for ((i=1; i>0; i+=1)); do r dc ps; echo "Rendered $i time"; sleep 1; done
  elif [[ $1 = "ls" ]]; then
    shift
    echo "starting watcher"; for((i=1; i>0; i+=1)); do r ls -lah; echo "Rendered $i time"; sleep 1; done
  else
    echo "starting watcher"; "$@"
  fi
}

unalias remmina 1>/dev/null 2>&1
remmina() {
  flatpak run --filesystem=$SSH_AUTH_SOCK --env=SSH_AUTH_SOCK=$SSH_AUTH_SOCK org.remmina.Remmina
}
